#include<iostream>
using namespace std;
/*
多态是C++面向对象的三大特性之一
多态分为两类
・静态多态：函数重载和运算符重载属于静态多态，复用函数名
・动态多态：派生类和虚函数实现运行时多态（大部分时候说的多态都是这种多态）
静态多态和动态多态的区别：
・静态多态的函数地址早绑定 - 编译阶段确定函数地址
・动态多态的函数地址晚绑定 - 运行阶段确定函数地址
*/
//下面通过案例进行讲解多态
//动物类
class Animal137101
{
public:
	virtual void speak()
	{
		cout << "动物在说话" << endl;
	}
};
//猫类
class Cat137101 :public Animal137101
{
public:
	//虚函数
	virtual void speak()//重写父类中的虚函数，子类中的virtual关键词可写可不写
	{
		cout << "小猫在说话" << endl;
	}
};
//狗类
class Dog137101 :public Animal137101
{
public:
	virtual void speak()//重写父类中的虚函数
	{
		cout << "小狗在说话" << endl;
	}
};
//执行说话的函数
//地址早绑定，在编译阶段就确认了函数的地址，因为现在是一个Animal对象
//如果想执行让猫说话，那么函数的地址就不能提前帮点，需要在运行阶段就进行绑定，也就是地址晚绑定
/*
动态多态函数满足条件
1、需要有继承关系
2、子类重写父类的虚函数
重写与重载时不一样的，重载是函数名相同而参数不一样，
重写：1、函数的返回值类型要相同
	  2、函数名要相同
	  3、形参列表中的所有内容也要相同
***子类中的virtual关键词是可写可不写的***
*/
//动态多态的使用
//父类的指针或者引用 执向子类对象
void doSpeak(Animal137101 &Animal137101)//Animal &animal = cat;父类的引用来去指向子类的传入的对象
{
	Animal137101.speak();//父类的指针可以直接指向子类对象
}
void test13710101()
{
	Cat137101 cat;
	doSpeak(cat);//执行结果：动物在说话，而本意是想执行猫在说话
	Dog137101 dog;
	doSpeak(dog);
}
int main137101()
{
	test13710101();
	system("pause");
	return 0;
}
/*
动态多态：函数地址晚绑定
多态满足条件：
・有继承关系
・子类重写父类中的虚函数
多态使用条件
・父类指针或引用指向子类对象
重写：函数返回值类型 函数名 参数列表 完全一致称为重写
*/